/*
  This file is part of qt-flutter-embedder.

  SPDX-FileCopyrightText: 2024 Klarälvdalens Datakonsult AB, a KDAB Group company <info@kdab.com>
  Author: Sérgio Martins <sergio.martins@kdab.com>

  SPDX-License-Identifier: GPL-3.0-only

  Contact KDAB at <info@kdab.com> for commercial licensing options.
*/

#include "Embedder.h"
#include "FlutterWindow.h"

#include <QOpenGLContext>
#include <QGuiApplication>
#include <QThread>
#include <QDebug>

#include <iostream>
#include <filesystem>

using namespace KDAB;
namespace fs = std::filesystem;

static bool isAOT()
{
#ifdef FLUTTER_AOT
    return true;
#endif
    return false;
}

Embedder::Embedder()
{
    auto window = new FlutterWindow(*this);
    window->show();
    window->resize(1000, 1000);
    m_windows << window;
}

bool Embedder::runFlutter(const FlutterRendererConfig &config, const FlutterProjectArgs &args)
{
    FlutterEngineResult result =
        FlutterEngineRun(FLUTTER_ENGINE_VERSION, &config,
                         &args, this, &m_flutterEngine);

    return result == kSuccess;
}

_FlutterEngine *Embedder::engine() const
{
    return m_flutterEngine;
}

FlutterWindow &Embedder::mainWindow() const
{
    return *m_windows.first();
}

bool Embedder::initFlutter(int argc, char **argv, const std::string &project_path, const std::string &icudtl_path)
{
    if (!fs::exists(project_path)) {
        std::cerr << "Project not found: " << project_path << "\n";
        std::abort();
    }

    if (!fs::exists(icudtl_path)) {
        std::cerr << "icudtl not found: " << icudtl_path << "\n";
        std::abort();
    }

    FlutterWindow *window = &mainWindow();

    FlutterRendererConfig config = {};
    config.type = kOpenGL;
    config.open_gl.struct_size = sizeof(config.open_gl);
    config.open_gl.make_current = [](void *userdata) -> bool {
        auto embedder = reinterpret_cast<Embedder *>(userdata);
        embedder->maybeCreateGLContext();

        const bool result = embedder->glContext()->makeCurrent(&embedder->mainWindow());
        if (!result)
            qWarning() << "Failed to make context current" << "main thread=" << qApp->thread();

        return result;
    };
    config.open_gl.clear_current = [](void *) -> bool {
        // qDebug() << "clear_current: ";
        QOpenGLContext::currentContext()->doneCurrent();
        return true;
    };

    config.open_gl.present_with_info = [](void *userdata, const FlutterPresentInfo *) -> bool {
        // qDebug() << "present2: ";
        auto embedder = reinterpret_cast<Embedder *>(userdata);
        auto &window = embedder->mainWindow();
        embedder->glContext()->swapBuffers(&window);
        return true;
    };

    config.open_gl.fbo_callback = [](void *) -> uint32_t {
        // qDebug() << "fbo_callback: " << 0;
        return 0; // FBO0
    };
    config.open_gl.gl_proc_resolver = [](void *userdata, const char *name) -> void * {
        // qDebug() << "proc_resolver: " << "; name=" << name << "\n";
        auto embedder = reinterpret_cast<Embedder *>(userdata);
        return reinterpret_cast<void *>(embedder->glContext()->getProcAddress(name));
    };

    // This directory is generated by `flutter build bundle`. Used both in AOT and JIT mode
    const std::string assets_path = project_path + "/build/flutter_assets";

    FlutterEngineAOTData aot_data = nullptr;
    if (isAOT()) {
        // flutter build linux --release , for AOT mode
        const std::string aot_elf = project_path + "/build/linux/x64/release/bundle/lib/libapp.so";
        std::cout << "embedder: Using aot_elf=" << aot_elf << std::endl;

        const FlutterEngineAOTDataSource source = { .type = kFlutterEngineAOTDataSourceTypeElfPath, .elf_path = aot_elf.c_str() };
        auto res = FlutterEngineCreateAOTData(&source, &aot_data);
        if (res != kSuccess || !aot_data) {
            std::cerr << "Could not prepare AOT data result=" << int(res) << "\n";
            return false;
        }
    }

    FlutterProjectArgs args = {
        .struct_size = sizeof(FlutterProjectArgs),
        .assets_path = assets_path.c_str(),
        .icu_data_path =
            icudtl_path.c_str(), // Find this in your bin/cache directory.
        .command_line_argc = argc,
        .command_line_argv = argv,
        .aot_data = aot_data,
        .dart_entrypoint_argc = argc,
        .dart_entrypoint_argv = argv,
    };

    if (!runFlutter(config, args)) {
        std::cout << "Could not run the Flutter Engine." << std::endl;
        return false;
    }

    return true;
}

void Embedder::maybeCreateGLContext()
{
    if (m_glContext)
        return;

    m_glContext = new QOpenGLContext();
    m_glContext->setFormat(surfaceFormat());
    if (!m_glContext->create())
        qFatal("Could not create opengl context");
}

QSurfaceFormat Embedder::surfaceFormat()
{
    QSurfaceFormat fmt;
    fmt.setDepthBufferSize(8);
    fmt.setStencilBufferSize(8);
    fmt.setAlphaBufferSize(8);
    fmt.setSamples(8);

    return fmt;
}

QOpenGLContext *Embedder::glContext() const
{
    return m_glContext;
}

FlutterWindow *Embedder::addWindow()
{
    auto window = new FlutterWindow(*this);

    FlutterAddViewInfo info;
    info.struct_size = sizeof(info);
    info.view_id = window->id();
    info.user_data = window;

    info.add_view_callback = [](const FlutterAddViewResult *result) {
        if (result->added) {
            auto window = reinterpret_cast<FlutterWindow *>(result->user_data);

            // re-thread
            QMetaObject::invokeMethod(window, [window] {
                window->show();
            });

        } else {
            qDebug() << "Embedder: Could not add view!";
        }
    };

    auto result = FlutterEngineAddView(m_flutterEngine, &info);
    if (result != kSuccess) {
        qWarning() << "Embedder: Error adding view";
        delete window;
        return nullptr;
    }

    window->setTitle("SECOND");
    m_windows << window;

    return window;
}
