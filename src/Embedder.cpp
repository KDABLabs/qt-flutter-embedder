/*
  This file is part of qt-flutter-embedder.

  SPDX-FileCopyrightText: 2024 Klarälvdalens Datakonsult AB, a KDAB Group company <info@kdab.com>
  Author: Sérgio Martins <sergio.martins@kdab.com>

  SPDX-License-Identifier: GPL-3.0-only

  Contact KDAB at <info@kdab.com> for commercial licensing options.
*/

#include "Embedder.h"
#include "FlutterWindow.h"
#include "flutter_embedder.h"

#include <QOpenGLContext>
#include <QGuiApplication>
#include <QThread>
#include <QDebug>
#include <QLoggingCategory>
#include <QColorSpace>

#include <iostream>
#include <filesystem>

// TODO: In the future we won't need to link to GL directly
// only in a developer build where we call gl functions directly
#include <EGL/egl.h>
#include <GLES3/gl3.h>

Q_LOGGING_CATEGORY(qtembedder, "qtembedder")

using namespace KDAB;
namespace fs = std::filesystem;

static bool isAOT()
{
#ifdef FLUTTER_AOT
    return true;
#endif
    return false;
}

Embedder::Embedder(bool multiWindowMode)
    : m_multiWindowMode(multiWindowMode)
{
    auto window = new FlutterWindow(*this);
    window->show();
    window->resize(1000, 1000);
    m_windows << window;
}

bool Embedder::runFlutter(const FlutterRendererConfig &config, const FlutterProjectArgs &args)
{
    FlutterEngineResult result =
        FlutterEngineRun(FLUTTER_ENGINE_VERSION, &config,
                         &args, this, &m_flutterEngine);

    return result == kSuccess;
}

_FlutterEngine *Embedder::engine() const
{
    return m_flutterEngine;
}

FlutterWindow &Embedder::mainWindow() const
{
    return *m_windows.first();
}

bool Embedder::initFlutter(int argc, char **argv, const std::string &project_path, const std::string &icudtl_path)
{
    if (!fs::exists(project_path)) {
        std::cerr << "Project not found: " << project_path << "\n";
        std::abort();
    }

    if (!fs::exists(icudtl_path)) {
        std::cerr << "icudtl not found: " << icudtl_path << "\n";
        std::abort();
    }

    FlutterRendererConfig config = {};
    config.type = kOpenGL;
    config.open_gl.struct_size = sizeof(config.open_gl);
    config.open_gl.make_current = [](void *userdata) -> bool {
        qCInfo(qtembedder) << "make_current:";

        auto embedder = reinterpret_cast<Embedder *>(userdata);

        // only run once.
        embedder->maybeCreateGLContext();

        const bool result = embedder->glContext()->makeCurrent(&embedder->mainWindow());
        if (!result)
            qCWarning(qtembedder) << "Failed to make context current" << "main thread=" << qApp->thread();

        embedder->dumpGLInfo();

        return result;
    };

    config.open_gl.clear_current = [](void *) -> bool {
        qCInfo(qtembedder) << "clear_current:";
        QOpenGLContext::currentContext()->doneCurrent();
        return true;
    };

    config.open_gl.present_with_info = [](void *userdata, const FlutterPresentInfo *) -> bool {
        qCInfo(qtembedder) << "present_with_info:";

        auto embedder = reinterpret_cast<Embedder *>(userdata);
        Q_ASSERT(!embedder->isMultiWindowMode());

        auto &window = embedder->mainWindow();
        embedder->glContext()->swapBuffers(&window);
        return true;
    };

    config.open_gl.fbo_callback = [](void *) -> uint32_t {
        qCInfo(qtembedder) << "fbo_callback:";
        return 0;
    };

    config.open_gl.gl_proc_resolver = [](void *userdata, const char *name) -> void * {
        auto embedder = reinterpret_cast<Embedder *>(userdata);
        return reinterpret_cast<void *>(embedder->glContext()->getProcAddress(name));
    };

    // This directory is generated by `flutter build bundle`. Used both in AOT and JIT mode
    const std::string assets_path = project_path + "/build/flutter_assets";

    FlutterEngineAOTData aot_data = nullptr;
    if (isAOT()) {
        // flutter build linux --release , for AOT mode
        const std::string aot_elf = project_path + "/build/linux/x64/release/bundle/lib/libapp.so";
        std::cout << "embedder: Using aot_elf=" << aot_elf << std::endl;

        const FlutterEngineAOTDataSource source = { .type = kFlutterEngineAOTDataSourceTypeElfPath, .elf_path = aot_elf.c_str() };
        auto res = FlutterEngineCreateAOTData(&source, &aot_data);
        if (res != kSuccess || !aot_data) {
            std::cerr << "Could not prepare AOT data result=" << int(res) << "\n";
            return false;
        }
    }

    m_flutterCompositor = {};
    // In multiwindow mode we need a compositor
    if (m_multiWindowMode) {
        m_flutterCompositor.struct_size = sizeof(m_flutterCompositor);
        m_flutterCompositor.user_data = this;
        m_flutterCompositor.present_view_callback = [](const FlutterPresentViewInfo *info) {
            // TODO
            qCInfo(qtembedder) << "compositor.present_view_callback:";
            auto embedder = reinterpret_cast<Embedder *>(info->user_data);
            auto &window = embedder->mainWindow();
            embedder->glContext()->swapBuffers(&window);
            return true;
        };

        m_flutterCompositor.collect_backing_store_callback = [](const FlutterBackingStore *, void *) {
            qCInfo(qtembedder) << "compositor.collect_backing_store_callback:";
            return true;
        };

        m_flutterCompositor.create_backing_store_callback = [](const FlutterBackingStoreConfig *config,
                                                               FlutterBackingStore *backing_store_out,
                                                               void *user_data) {
            qCInfo(qtembedder) << "create_backing_store: view=" << config->view_id << "; size=" << config->size.width
                               << "x" << config->size.height;

            auto embedder = reinterpret_cast<Embedder *>(user_data);
            auto window = embedder->windowForId(config->view_id);
            Q_ASSERT(window); // TODO: Create it and actually assert if it existed already

            FlutterOpenGLSurface glSurface;
            glSurface.struct_size = sizeof(FlutterOpenGLSurface);
            glSurface.user_data = window;
            glSurface.make_current_callback = [](void *user_data, bool *state_changed) {
                *state_changed = false;
                auto window = reinterpret_cast<FlutterWindow *>(user_data);
                qCInfo(qtembedder) << "glSurface.make_current_callback id=" << window->id();
                return true;
            };

            glSurface.clear_current_callback = [](void *user_data, bool *state_changed) {
                *state_changed = false;
                auto window = reinterpret_cast<FlutterWindow *>(user_data);
                qCInfo(qtembedder) << "glSurface.clear_current_callback id=" << window->id();
                return true;
            };

            glSurface.destruction_callback = [](void *user_data) {
                auto window = reinterpret_cast<FlutterWindow *>(user_data);
                qCInfo(qtembedder) << "glSurface.destruction_callback id=" << window->id();
            };

            FlutterOpenGLBackingStore glStore;
            glStore.type = kFlutterOpenGLTargetTypeSurface;
            glStore.surface = glSurface;

            backing_store_out->struct_size = sizeof(FlutterBackingStore);
            backing_store_out->type = kFlutterBackingStoreTypeOpenGL;
            backing_store_out->user_data = window;
            // backing_store_out->did_update TODO
            backing_store_out->open_gl = glStore;

            return true;
        };

        m_flutterCompositor.avoid_backing_store_cache = true;
    }

    FlutterProjectArgs args = {
        .struct_size = sizeof(FlutterProjectArgs),
        .assets_path = assets_path.c_str(),
        .icu_data_path = icudtl_path.c_str(),
        .command_line_argc = argc,
        .command_line_argv = argv,
        .compositor = m_multiWindowMode ? &m_flutterCompositor : nullptr,
        .aot_data = aot_data,
        .dart_entrypoint_argc = argc,
        .dart_entrypoint_argv = argv,
    };

    if (!runFlutter(config, args)) {
        std::cout << "Could not run the Flutter Engine." << std::endl;
        return false;
    }

    return true;
}

void Embedder::maybeCreateGLContext()
{
    if (m_glContext)
        return;

    m_glContext = new QOpenGLContext();
    m_glContext->setFormat(surfaceFormat());
    if (!m_glContext->create())
        qFatal("Could not create opengl context");
}

QSurfaceFormat Embedder::surfaceFormat()
{
    QSurfaceFormat fmt;
    fmt.setColorSpace(QColorSpace::SRgb);
    fmt.setDepthBufferSize(8);
    fmt.setStencilBufferSize(8);
    fmt.setAlphaBufferSize(8);
    fmt.setSamples(8);

    return fmt;
}

QOpenGLContext *Embedder::glContext() const
{
    return m_glContext;
}

FlutterWindow *Embedder::addWindow()
{
    auto window = new FlutterWindow(*this);

    FlutterAddViewInfo info;
    info.struct_size = sizeof(info);
    info.view_id = window->id();
    info.user_data = window;

    info.add_view_callback = [](const FlutterAddViewResult *result) {
        if (result->added) {
            auto window = reinterpret_cast<FlutterWindow *>(result->user_data);

            // re-thread
            QMetaObject::invokeMethod(window, [window] {
                window->show();
            });

        } else {
            qCWarning(qtembedder) << "Embedder: Could not add view!";
        }
    };

    auto result = FlutterEngineAddView(m_flutterEngine, &info);
    if (result != kSuccess) {
        qCWarning(qtembedder) << "Embedder: Error adding view";
        delete window;
        return nullptr;
    }

    window->setTitle("SECOND");
    m_windows << window;

    return window;
}

FlutterWindow *Embedder::windowForId(FlutterViewId id) const
{
    auto it = std::find_if(m_windows.cbegin(), m_windows.cend(), [id](auto w) {
        return w->id() == id;
    });

    return it == m_windows.cend() ? nullptr : *it;
}

void Embedder::dumpGLInfo(bool printExtensions)
{
    Q_ASSERT(m_glContext);
    qCInfo(qtembedder) << "; format=" << m_glContext->format()
                       << "; GL_VERSION=" << ( const char * )glGetString(GL_VERSION);

    if (printExtensions) {
        int extensionCnt = 0;
        glGetIntegerv(GL_NUM_EXTENSIONS, &extensionCnt);

        const char *extensions = ( const char * )glGetString(GL_EXTENSIONS);
        Q_ASSERT(eglGetCurrentDisplay() != EGL_NO_DISPLAY);
        const GLubyte *renderer = glGetString(GL_RENDERER);
        const GLubyte *vendor = glGetString(GL_VENDOR);
        const GLubyte *version = glGetString(GL_VERSION);
        const GLubyte *glslVersion = glGetString(GL_SHADING_LANGUAGE_VERSION);

        qCInfo(qtembedder) << "Renderer: " << renderer;
        qCInfo(qtembedder) << "Vendor: " << vendor;
        qCInfo(qtembedder) << "OpenGL Version: " << version;
        qCInfo(qtembedder) << "GLSL Version: " << glslVersion;

        for (int i = 0; i < extensionCnt; ++i) {
            qCInfo(qtembedder) << ( const char * )glGetStringi(GL_EXTENSIONS, i);
        }
    }
}

bool Embedder::isMultiWindowMode() const
{
    return m_multiWindowMode;
}
